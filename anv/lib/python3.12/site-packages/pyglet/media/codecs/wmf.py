from __future__ import annotations

import os
import platform
import warnings
from ctypes import (
    HRESULT,
    POINTER,
    Structure,
    byref,
    c_int32,
    c_longlong,
    c_uint32,
    c_uint64,
    c_ulonglong,
    c_void_p,
    cast,
    memmove,
    string_at,
    windll,
)
from ctypes.wintypes import BOOL, DWORD, LONG, LPCWSTR, UINT, ULONG, WORD

from pyglet import image
from pyglet.libs.win32 import _kernel32 as kernel32
from pyglet.libs.win32 import _ole32 as ole32
from pyglet.libs.win32 import com
from pyglet.libs.win32.constants import (
    GMEM_MOVEABLE,
    MF_ACCESSMODE_READWRITE,
    MF_FILEFLAGS_NONE,
    MF_OPENMODE_DELETE_IF_EXIST,
    WINDOWS_7_OR_GREATER,
    WINDOWS_10_ANNIVERSARY_UPDATE_OR_GREATER,
    WINDOWS_VISTA_OR_GREATER,
)
from pyglet.libs.win32.types import BYTE, PROPVARIANT
from pyglet.media import Source
from pyglet.media.codecs import (
    AudioData,
    AudioFormat,
    MediaDecoder,
    StaticSource,
    VideoFormat,
)
from pyglet.util import DecodeException, debug_print

_debug = debug_print("debug_media")

try:
    mfreadwrite = "mfreadwrite"
    mfplat = "mfplat"

    # System32 and SysWOW64 folders are opposite perception in Windows x64.
    # System32 = x64 dll's | SysWOW64 = x86 dlls
    # By default ctypes only seems to look in system32 regardless of Python architecture, which has x64 dlls.
    if platform.architecture()[0] == "32bit" and platform.machine().endswith(
        "64"
    ):  # Machine is 64 bit, Python is 32 bit.
        mfreadwrite = os.path.join(os.environ["WINDIR"], "SysWOW64", "mfreadwrite.dll")
        mfplat = os.path.join(os.environ["WINDIR"], "SysWOW64", "mfplat.dll")

    mfreadwrite_lib = windll.LoadLibrary(mfreadwrite)
    mfplat_lib = windll.LoadLibrary(mfplat)
except OSError:
    # Doesn't exist? Should stop import of library.
    raise ImportError("Could not load WMF library.")

MF_SOURCE_READERF_ERROR = 0x00000001
MF_SOURCE_READERF_ENDOFSTREAM = 0x00000002
MF_SOURCE_READERF_NEWSTREAM = 0x00000004
MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED = 0x00000010
MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED = 0x00000020
MF_SOURCE_READERF_STREAMTICK = 0x00000100

# Audio attributes
MF_LOW_LATENCY = com.GUID(
    0x9C27891A, 0xED7A, 0x40E1, 0x88, 0xE8, 0xB2, 0x27, 0x27, 0xA0, 0x24, 0xEE
)

# Audio information
MF_MT_ALL_SAMPLES_INDEPENDENT = com.GUID(
    0xC9173739, 0x5E56, 0x461C, 0xB7, 0x13, 0x46, 0xFB, 0x99, 0x5C, 0xB9, 0x5F
)
MF_MT_FIXED_SIZE_SAMPLES = com.GUID(
    0xB8EBEFAF, 0xB718, 0x4E04, 0xB0, 0xA9, 0x11, 0x67, 0x75, 0xE3, 0x32, 0x1B
)
MF_MT_SAMPLE_SIZE = com.GUID(
    0xDAD3AB78, 0x1990, 0x408B, 0xBC, 0xE2, 0xEB, 0xA6, 0x73, 0xDA, 0xCC, 0x10
)
MF_MT_COMPRESSED = com.GUID(
    0x3AFD0CEE, 0x18F2, 0x4BA5, 0xA1, 0x10, 0x8B, 0xEA, 0x50, 0x2E, 0x1F, 0x92
)
MF_MT_WRAPPED_TYPE = com.GUID(
    0x4D3F7B23, 0xD02F, 0x4E6C, 0x9B, 0xEE, 0xE4, 0xBF, 0x2C, 0x6C, 0x69, 0x5D
)
MF_MT_AUDIO_NUM_CHANNELS = com.GUID(
    0x37E48BF5, 0x645E, 0x4C5B, 0x89, 0xDE, 0xAD, 0xA9, 0xE2, 0x9B, 0x69, 0x6A
)
MF_MT_AUDIO_SAMPLES_PER_SECOND = com.GUID(
    0x5FAEEAE7, 0x0290, 0x4C31, 0x9E, 0x8A, 0xC5, 0x34, 0xF6, 0x8D, 0x9D, 0xBA
)
MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND = com.GUID(
    0xFB3B724A, 0xCFB5, 0x4319, 0xAE, 0xFE, 0x6E, 0x42, 0xB2, 0x40, 0x61, 0x32
)
MF_MT_AUDIO_AVG_BYTES_PER_SECOND = com.GUID(
    0x1AAB75C8, 0xCFEF, 0x451C, 0xAB, 0x95, 0xAC, 0x03, 0x4B, 0x8E, 0x17, 0x31
)
MF_MT_AUDIO_BLOCK_ALIGNMENT = com.GUID(
    0x322DE230, 0x9EEB, 0x43BD, 0xAB, 0x7A, 0xFF, 0x41, 0x22, 0x51, 0x54, 0x1D
)
MF_MT_AUDIO_BITS_PER_SAMPLE = com.GUID(
    0xF2DEB57F, 0x40FA, 0x4764, 0xAA, 0x33, 0xED, 0x4F, 0x2D, 0x1F, 0xF6, 0x69
)
MF_MT_AUDIO_VALID_BITS_PER_SAMPLE = com.GUID(
    0xD9BF8D6A, 0x9530, 0x4B7C, 0x9D, 0xDF, 0xFF, 0x6F, 0xD5, 0x8B, 0xBD, 0x06
)
MF_MT_AUDIO_SAMPLES_PER_BLOCK = com.GUID(
    0xAAB15AAC, 0xE13A, 0x4995, 0x92, 0x22, 0x50, 0x1E, 0xA1, 0x5C, 0x68, 0x77
)
MF_MT_AUDIO_CHANNEL_MASK = com.GUID(
    0x55FB5765, 0x644A, 0x4CAF, 0x84, 0x79, 0x93, 0x89, 0x83, 0xBB, 0x15, 0x88
)
MF_PD_DURATION = com.GUID(
    0x6C990D33, 0xBB8E, 0x477A, 0x85, 0x98, 0xD, 0x5D, 0x96, 0xFC, 0xD8, 0x8A
)


# Media types categories
MF_MT_MAJOR_TYPE = com.GUID(
    0x48EBA18E, 0xF8C9, 0x4687, 0xBF, 0x11, 0x0A, 0x74, 0xC9, 0xF9, 0x6A, 0x8F
)
MF_MT_SUBTYPE = com.GUID(
    0xF7E34C9A, 0x42E8, 0x4714, 0xB7, 0x4B, 0xCB, 0x29, 0xD7, 0x2C, 0x35, 0xE5
)

# Major types
MFMediaType_Audio = com.GUID(
    0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
)
MFMediaType_Video = com.GUID(
    0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
)
MFMediaType_Protected = com.GUID(
    0x7B4B6FE6, 0x9D04, 0x4494, 0xBE, 0x14, 0x7E, 0x0B, 0xD0, 0x76, 0xC8, 0xE4
)
MFMediaType_Image = com.GUID(
    0x72178C23, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB
)
MFMediaType_HTML = com.GUID(
    0x72178C24, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB
)
MFMediaType_Subtitle = com.GUID(
    0xA6D13581, 0xED50, 0x4E65, 0xAE, 0x08, 0x26, 0x06, 0x55, 0x76, 0xAA, 0xCC
)

# Video subtypes, attributes, and enums (Uncompressed)
D3DFMT_X8R8G8B8 = 22
D3DFMT_P8 = 41
D3DFMT_A8R8G8B8 = 21
MFVideoFormat_RGB32 = com.GUID(
    D3DFMT_X8R8G8B8, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
)
MFVideoFormat_RGB8 = com.GUID(
    D3DFMT_P8, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
)
MFVideoFormat_ARGB32 = com.GUID(
    D3DFMT_A8R8G8B8, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
)

MFVideoInterlace_Progressive = 2
MF_MT_INTERLACE_MODE = com.GUID(
    0xE2724BB8, 0xE676, 0x4806, 0xB4, 0xB2, 0xA8, 0xD6, 0xEF, 0xB4, 0x4C, 0xCD
)
MF_MT_FRAME_SIZE = com.GUID(
    0x1652C33D, 0xD6B2, 0x4012, 0xB8, 0x34, 0x72, 0x03, 0x08, 0x49, 0xA3, 0x7D
)
MF_MT_FRAME_RATE = com.GUID(
    0xC459A2E8, 0x3D2C, 0x4E44, 0xB1, 0x32, 0xFE, 0xE5, 0x15, 0x6C, 0x7B, 0xB0
)
MF_MT_PIXEL_ASPECT_RATIO = com.GUID(
    0xC6376A1E, 0x8D0A, 0x4027, 0xBE, 0x45, 0x6D, 0x9A, 0x0A, 0xD3, 0x9B, 0xB6
)
MF_MT_DRM_FLAGS = com.GUID(
    0x8772F323, 0x355A, 0x4CC7, 0xBB, 0x78, 0x6D, 0x61, 0xA0, 0x48, 0xAE, 0x82
)
MF_MT_DEFAULT_STRIDE = com.GUID(
    0x644B4E48, 0x1E02, 0x4516, 0xB0, 0xEB, 0xC0, 0x1C, 0xA9, 0xD4, 0x9A, 0xC6
)

# Audio Subtypes (Uncompressed)
WAVE_FORMAT_PCM = 1
WAVE_FORMAT_IEEE_FLOAT = 3
MFAudioFormat_PCM = com.GUID(
    WAVE_FORMAT_PCM, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
)
MFAudioFormat_Float = com.GUID(
    WAVE_FORMAT_IEEE_FLOAT,
    0x0000,
    0x0010,
    0x80,
    0x00,
    0x00,
    0xAA,
    0x00,
    0x38,
    0x9B,
    0x71,
)

# Image subtypes.
MFImageFormat_RGB32 = com.GUID(
    0x00000016, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
)
MFImageFormat_JPEG = com.GUID(
    0x19E4A5AA, 0x5662, 0x4FC5, 0xA0, 0xC0, 0x17, 0x58, 0x02, 0x8E, 0x10, 0x57
)

# Video attributes
# Enables hardware decoding
MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS = com.GUID(
    0xA634A91C, 0x822B, 0x41B9, 0xA4, 0x94, 0x4D, 0xE4, 0x64, 0x36, 0x12, 0xB0
)
# Enable video decoding
MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING = com.GUID(
    0xFB394F3D, 0xCCF1, 0x42EE, 0xBB, 0xB3, 0xF9, 0xB8, 0x45, 0xD5, 0x68, 0x1D
)
MF_SOURCE_READER_D3D_MANAGER = com.GUID(
    0xEC822DA2, 0xE1E9, 0x4B29, 0xA0, 0xD8, 0x56, 0x3C, 0x71, 0x9F, 0x52, 0x69
)
MF_MEDIA_ENGINE_DXGI_MANAGER = com.GUID(
    0x065702DA, 0x1094, 0x486D, 0x86, 0x17, 0xEE, 0x7C, 0xC4, 0xEE, 0x46, 0x48
)
MF_SOURCE_READER_ENABLE_ADVANCED_VIDEO_PROCESSING = com.GUID(
    0xF81DA2C, 0xB537, 0x4672, 0xA8, 0xB2, 0xA6, 0x81, 0xB1, 0x73, 0x7, 0xA3
)

# Some common errors
MF_E_INVALIDSTREAMNUMBER = -1072875853  # 0xC00D36B3
MF_E_UNSUPPORTED_BYTESTREAM_TYPE = -1072875836  # 0xC00D36C4
MF_E_NO_MORE_TYPES = 0xC00D36B9
MF_E_TOPO_CODEC_NOT_FOUND = -1072868846  # 0xC00D5212


VT_I8 = 20  # Only enum we care about: https://docs.microsoft.com/en-us/windows/win32/api/wtypes/ne-wtypes-varenum


def timestamp_from_wmf(timestamp):  # 100-nanoseconds
    return float(timestamp) / 10000000


def timestamp_to_wmf(timestamp):  # 100-nanoseconds
    return int(timestamp * 10000000)


class IMFAttributes(com.pIUnknown):
    _methods_ = [
        ("GetItem", com.STDMETHOD()),
        ("GetItemType", com.STDMETHOD()),
        ("CompareItem", com.STDMETHOD()),
        ("Compare", com.STDMETHOD()),
        ("GetUINT32", com.STDMETHOD(com.REFIID, POINTER(c_uint32))),
        ("GetUINT64", com.STDMETHOD(com.REFIID, POINTER(c_uint64))),
        ("GetDouble", com.STDMETHOD()),
        ("GetGUID", com.STDMETHOD(com.REFIID, POINTER(com.GUID))),
        ("GetStringLength", com.STDMETHOD()),
        ("GetString", com.STDMETHOD()),
        ("GetAllocatedString", com.STDMETHOD()),
        ("GetBlobSize", com.STDMETHOD()),
        ("GetBlob", com.STDMETHOD()),
        ("GetAllocatedBlob", com.STDMETHOD()),
        ("GetUnknown", com.STDMETHOD()),
        ("SetItem", com.STDMETHOD()),
        ("DeleteItem", com.STDMETHOD()),
        ("DeleteAllItems", com.STDMETHOD()),
        ("SetUINT32", com.STDMETHOD(com.REFIID, c_uint32)),
        ("SetUINT64", com.STDMETHOD()),
        ("SetDouble", com.STDMETHOD()),
        ("SetGUID", com.STDMETHOD(com.REFIID, com.REFIID)),
        ("SetString", com.STDMETHOD()),
        ("SetBlob", com.STDMETHOD()),
        ("SetUnknown", com.STDMETHOD(com.REFIID, com.pIUnknown)),
        ("LockStore", com.STDMETHOD()),
        ("UnlockStore", com.STDMETHOD()),
        ("GetCount", com.STDMETHOD()),
        ("GetItemByIndex", com.STDMETHOD()),
        ("CopyAllItems", com.STDMETHOD(c_void_p)),  # IMFAttributes
    ]


class IMFMediaBuffer(com.pIUnknown):
    _methods_ = [
        ("Lock", com.STDMETHOD(POINTER(POINTER(BYTE)), POINTER(DWORD), POINTER(DWORD))),
        ("Unlock", com.STDMETHOD()),
        ("GetCurrentLength", com.STDMETHOD(POINTER(DWORD))),
        ("SetCurrentLength", com.STDMETHOD(DWORD)),
        ("GetMaxLength", com.STDMETHOD(POINTER(DWORD))),
    ]


class IMFSample(IMFAttributes, com.pIUnknown):
    _methods_ = [
        ("GetSampleFlags", com.STDMETHOD()),
        ("SetSampleFlags", com.STDMETHOD()),
        ("GetSampleTime", com.STDMETHOD()),
        ("SetSampleTime", com.STDMETHOD()),
        ("GetSampleDuration", com.STDMETHOD(POINTER(c_ulonglong))),
        ("SetSampleDuration", com.STDMETHOD(DWORD, IMFMediaBuffer)),
        ("GetBufferCount", com.STDMETHOD(POINTER(DWORD))),
        ("GetBufferByIndex", com.STDMETHOD(DWORD, IMFMediaBuffer)),
        ("ConvertToContiguousBuffer", com.STDMETHOD(POINTER(IMFMediaBuffer))),  # out
        ("AddBuffer", com.STDMETHOD(POINTER(DWORD))),
        ("RemoveBufferByIndex", com.STDMETHOD()),
        ("RemoveAllBuffers", com.STDMETHOD()),
        ("GetTotalLength", com.STDMETHOD(POINTER(DWORD))),
        ("CopyToBuffer", com.STDMETHOD()),
    ]


class IMFMediaType(IMFAttributes, com.pIUnknown):
    _methods_ = [
        ("GetMajorType", com.STDMETHOD()),
        ("IsCompressedFormat", com.STDMETHOD()),
        ("IsEqual", com.STDMETHOD()),
        ("GetRepresentation", com.STDMETHOD()),
        ("FreeRepresentation", com.STDMETHOD()),
    ]


class IMFByteStream(com.pIUnknown):
    _methods_ = [
        ("GetCapabilities", com.STDMETHOD()),
        ("GetLength", com.STDMETHOD()),
        ("SetLength", com.STDMETHOD()),
        ("GetCurrentPosition", com.STDMETHOD()),
        ("SetCurrentPosition", com.STDMETHOD(c_ulonglong)),
        ("IsEndOfStream", com.STDMETHOD()),
        ("Read", com.STDMETHOD()),
        ("BeginRead", com.STDMETHOD()),
        ("EndRead", com.STDMETHOD()),
        ("Write", com.STDMETHOD(POINTER(BYTE), ULONG, POINTER(ULONG))),
        ("BeginWrite", com.STDMETHOD()),
        ("EndWrite", com.STDMETHOD()),
        ("Seek", com.STDMETHOD()),
        ("Flush", com.STDMETHOD()),
        ("Close", com.STDMETHOD()),
    ]


class IMFSourceReader(com.pIUnknown):
    _methods_ = [
        ("GetStreamSelection", com.STDMETHOD(DWORD, POINTER(BOOL))),  # in, out
        ("SetStreamSelection", com.STDMETHOD(DWORD, BOOL)),
        ("GetNativeMediaType", com.STDMETHOD(DWORD, DWORD, POINTER(IMFMediaType))),
        ("GetCurrentMediaType", com.STDMETHOD(DWORD, POINTER(IMFMediaType))),
        ("SetCurrentMediaType", com.STDMETHOD(DWORD, POINTER(DWORD), IMFMediaType)),
        ("SetCurrentPosition", com.STDMETHOD(com.REFIID, POINTER(PROPVARIANT))),
        (
            "ReadSample",
            com.STDMETHOD(
                DWORD,
                DWORD,
                POINTER(DWORD),
                POINTER(DWORD),
                POINTER(c_longlong),
                POINTER(IMFSample),
            ),
        ),
        ("Flush", com.STDMETHOD(DWORD)),  # in
        ("GetServiceForStream", com.STDMETHOD()),
        (
            "GetPresentationAttribute",
            com.STDMETHOD(DWORD, com.REFIID, POINTER(PROPVARIANT)),
        ),
    ]


class WAVEFORMATEX(Structure):
    _fields_ = [
        ("wFormatTag", WORD),
        ("nChannels", WORD),
        ("nSamplesPerSec", DWORD),
        ("nAvgBytesPerSec", DWORD),
        ("nBlockAlign", WORD),
        ("wBitsPerSample", WORD),
        ("cbSize", WORD),
    ]

    def __repr__(self):
        return (
            f"WAVEFORMATEX(wFormatTag={self.wFormatTag}, nChannels={self.nChannels}, nSamplesPerSec={self.nSamplesPerSec}, nAvgBytesPersec={self.nAvgBytesPerSec}"
            f", nBlockAlign={self.nBlockAlign}, wBitsPerSample={self.wBitsPerSample}, cbSize={self.cbSize})"
        )


# Stream constants
MF_SOURCE_READER_ALL_STREAMS = 0xFFFFFFFE
MF_SOURCE_READER_ANY_STREAM = 4294967294  # 0xfffffffe
MF_SOURCE_READER_FIRST_AUDIO_STREAM = 4294967293  # 0xfffffffd
MF_SOURCE_READER_FIRST_VIDEO_STREAM = 0xFFFFFFFC
MF_SOURCE_READER_MEDIASOURCE = 0xFFFFFFFF

# Version calculation
if WINDOWS_7_OR_GREATER:
    MF_SDK_VERSION = 0x0002
else:
    MF_SDK_VERSION = 0x0001

MF_API_VERSION = 0x0070  # Only used in Vista.

MF_VERSION = MF_SDK_VERSION << 16 | MF_API_VERSION

MFStartup = mfplat_lib.MFStartup
MFStartup.restype = HRESULT
MFStartup.argtypes = [LONG, DWORD]

MFShutdown = mfplat_lib.MFShutdown
MFShutdown.restype = HRESULT
MFShutdown.argtypes = []

MFCreateAttributes = mfplat_lib.MFCreateAttributes
MFCreateAttributes.restype = HRESULT
MFCreateAttributes.argtypes = [
    POINTER(IMFAttributes),
    c_uint32,
]  # attributes, cInitialSize

MFCreateSourceReaderFromURL = mfreadwrite_lib.MFCreateSourceReaderFromURL
MFCreateSourceReaderFromURL.restype = HRESULT
MFCreateSourceReaderFromURL.argtypes = [
    LPCWSTR,
    IMFAttributes,
    POINTER(IMFSourceReader),
]

MFCreateSourceReaderFromByteStream = mfreadwrite_lib.MFCreateSourceReaderFromByteStream
MFCreateSourceReaderFromByteStream.restype = HRESULT
MFCreateSourceReaderFromByteStream.argtypes = [
    IMFByteStream,
    IMFAttributes,
    POINTER(IMFSourceReader),
]

if WINDOWS_7_OR_GREATER:
    MFCreateMFByteStreamOnStream = mfplat_lib.MFCreateMFByteStreamOnStream
    MFCreateMFByteStreamOnStream.restype = HRESULT
    MFCreateMFByteStreamOnStream.argtypes = [c_void_p, POINTER(IMFByteStream)]

MFCreateTempFile = mfplat_lib.MFCreateTempFile
MFCreateTempFile.restype = HRESULT
MFCreateTempFile.argtypes = [UINT, UINT, UINT, POINTER(IMFByteStream)]

MFCreateMediaType = mfplat_lib.MFCreateMediaType
MFCreateMediaType.restype = HRESULT
MFCreateMediaType.argtypes = [POINTER(IMFMediaType)]

MFCreateWaveFormatExFromMFMediaType = mfplat_lib.MFCreateWaveFormatExFromMFMediaType
MFCreateWaveFormatExFromMFMediaType.restype = HRESULT
MFCreateWaveFormatExFromMFMediaType.argtypes = [
    IMFMediaType,
    POINTER(POINTER(WAVEFORMATEX)),
    POINTER(c_uint32),
    c_uint32,
]


class WMFSource(Source):
    low_latency = True  # Quicker latency but possible quality loss.

    decode_audio = True
    decode_video = True

    def __init__(self, filename, file=None):
        assert any(
            [self.decode_audio, self.decode_video]
        ), "Source must decode audio, video, or both, not none."
        self._current_video_sample = None
        self._current_video_buffer = None
        self._timestamp = 0
        self._attributes = None
        self._stream_obj = None
        self._imf_bytestream = None
        self._wfx = None
        self._stride = None

        self.set_config_attributes()

        # Create SourceReader
        self._source_reader = IMFSourceReader()

        # If it's a file, we need to load it as a stream.
        if file is not None:
            data = file.read()

            self._imf_bytestream = IMFByteStream()

            data_len = len(data)

            if WINDOWS_7_OR_GREATER:
                # Stole code from GDIPlus for older IStream support.
                hglob = kernel32.GlobalAlloc(GMEM_MOVEABLE, data_len)
                ptr = kernel32.GlobalLock(hglob)
                memmove(ptr, data, data_len)
                kernel32.GlobalUnlock(hglob)

                # Create IStream
                self._stream_obj = com.pIUnknown()
                ole32.CreateStreamOnHGlobal(hglob, True, byref(self._stream_obj))

                # MFCreateMFByteStreamOnStreamEx for future async operations exists, however Windows 8+ only. Requires new interface
                # (Also unsure how/if new Windows async functions and callbacks work with )
                MFCreateMFByteStreamOnStream(
                    self._stream_obj, byref(self._imf_bytestream)
                )
            else:
                # Vista does not support MFCreateMFByteStreamOnStream.
                # HACK: Create file in Windows temp folder to write our byte data to.
                # (Will be automatically deleted when IMFByteStream is Released.)
                MFCreateTempFile(
                    MF_ACCESSMODE_READWRITE,
                    MF_OPENMODE_DELETE_IF_EXIST,
                    MF_FILEFLAGS_NONE,
                    byref(self._imf_bytestream),
                )

                wrote_length = ULONG()
                data_ptr = cast(data, POINTER(BYTE))
                self._imf_bytestream.Write(data_ptr, data_len, byref(wrote_length))
                self._imf_bytestream.SetCurrentPosition(0)

                if wrote_length.value != data_len:
                    raise DecodeException(
                        "Could not write all of the data to the bytestream file."
                    )

            try:
                MFCreateSourceReaderFromByteStream(
                    self._imf_bytestream, self._attributes, byref(self._source_reader)
                )
            except OSError as err:
                raise DecodeException(err) from None
        else:
            # We can just load from filename if no file object specified..
            try:
                MFCreateSourceReaderFromURL(
                    filename, self._attributes, byref(self._source_reader)
                )
            except OSError as err:
                raise DecodeException(err) from None

        if self.decode_audio:
            self._load_audio()

        if self.decode_video:
            self._load_video()

        assert (
            self.audio_format or self.video_format
        ), "Source was decoded, but no video or audio streams were found."

        # Get duration of the media file after everything has been ok to decode.
        try:
            prop = PROPVARIANT()
            self._source_reader.GetPresentationAttribute(
                MF_SOURCE_READER_MEDIASOURCE, byref(MF_PD_DURATION), byref(prop)
            )

            self._duration = timestamp_from_wmf(prop.llVal)
            ole32.PropVariantClear(byref(prop))
        except OSError:
            warnings.warn(f"Could not determine duration of media file: '{filename}'.")

    def _load_audio(self, stream=MF_SOURCE_READER_FIRST_AUDIO_STREAM):
        """Prepares the audio stream for playback by detecting if it's compressed and attempting to decompress to PCM.
        Default: Only get the first available audio stream.
        """
        # Will be an audio file.
        self._audio_stream_index = stream

        # Get what the native/real media type is (audio only)
        imfmedia = IMFMediaType()

        try:
            self._source_reader.GetNativeMediaType(
                self._audio_stream_index, 0, byref(imfmedia)
            )
        except OSError as err:
            if err.winerror == MF_E_INVALIDSTREAMNUMBER:
                assert _debug("WMFAudioDecoder: No audio stream found.")
            return

        # Get Major media type (Audio, Video, etc)
        # TODO: Make GUID take no arguments for a null version:
        guid_audio_type = com.GUID(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

        imfmedia.GetGUID(MF_MT_MAJOR_TYPE, byref(guid_audio_type))

        if guid_audio_type == MFMediaType_Audio:
            assert _debug("WMFAudioDecoder: Found Audio Stream.")

            # Deselect any other streams if we don't need them. (Small speedup)
            if not self.decode_video:
                self._source_reader.SetStreamSelection(
                    MF_SOURCE_READER_ANY_STREAM, False
                )

            # Select first audio stream.
            self._source_reader.SetStreamSelection(
                MF_SOURCE_READER_FIRST_AUDIO_STREAM, True
            )

            # Check sub media type, AKA what kind of codec
            source_subtype_guid = com.GUID(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            source_sample_size = c_uint32()
            source_channel_count = c_uint32()

            imfmedia.GetGUID(MF_MT_SUBTYPE, byref(source_subtype_guid))
            try:
                # Some formats such as mp3 do not report this value
                imfmedia.GetUINT32(
                    MF_MT_AUDIO_BITS_PER_SAMPLE, byref(source_sample_size)
                )
            except OSError:
                source_sample_size.value = 0
            imfmedia.GetUINT32(MF_MT_AUDIO_NUM_CHANNELS, byref(source_channel_count))

            if (
                source_subtype_guid == MFAudioFormat_PCM
                and source_sample_size.value in (8, 16)
                and source_channel_count.value in (1, 2)
            ):
                assert _debug(
                    f"WMFAudioDecoder: Found compatible Integer PCM Audio: {source_subtype_guid}"
                )
            else:
                assert _debug(
                    f"WMFAudioDecoder: Found incompatible Audio: {source_subtype_guid}, "
                    f"sample size={source_sample_size.value}, channel count={source_channel_count.value}."
                    f"Attempting to decode/resample."
                )
                # If audio is compressed or incompatible, attempt to decompress or resample it
                # to standard 16bit integer PCM
                samples_per_sec = c_uint32()
                imfmedia.GetUINT32(
                    MF_MT_AUDIO_SAMPLES_PER_SECOND, byref(samples_per_sec)
                )

                channels_out = min(2, source_channel_count.value)

                mf_mediatype = IMFMediaType()
                MFCreateMediaType(byref(mf_mediatype))
                mf_mediatype.SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio)
                mf_mediatype.SetGUID(MF_MT_SUBTYPE, MFAudioFormat_PCM)
                mf_mediatype.SetUINT32(MF_MT_AUDIO_NUM_CHANNELS, channels_out)
                mf_mediatype.SetUINT32(MF_MT_AUDIO_BITS_PER_SAMPLE, 16)
                mf_mediatype.SetUINT32(
                    MF_MT_AUDIO_SAMPLES_PER_SECOND, samples_per_sec.value
                )
                mf_mediatype.SetUINT32(MF_MT_AUDIO_BLOCK_ALIGNMENT, channels_out * 2)
                mf_mediatype.SetUINT32(
                    MF_MT_AUDIO_AVG_BYTES_PER_SECOND,
                    samples_per_sec.value * channels_out * 2,
                )
                mf_mediatype.SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, 1)

                try:
                    self._source_reader.SetCurrentMediaType(
                        self._audio_stream_index, None, mf_mediatype
                    )
                except OSError as err:  # Can't decode codec.
                    raise DecodeException(err) from None

            # Current media type should now be properly decoded at this point.
            decoded_media_type = (
                IMFMediaType()
            )  # Maybe reusing older IMFMediaType will work?
            self._source_reader.GetCurrentMediaType(
                self._audio_stream_index, byref(decoded_media_type)
            )

            wfx_length = c_uint32()
            wfx = POINTER(WAVEFORMATEX)()

            MFCreateWaveFormatExFromMFMediaType(
                decoded_media_type, byref(wfx), byref(wfx_length), 0
            )

            self._wfx = wfx.contents
            self.audio_format = AudioFormat(
                channels=self._wfx.nChannels,
                sample_size=self._wfx.wBitsPerSample,
                sample_rate=self._wfx.nSamplesPerSec,
            )
        else:
            assert _debug("WMFAudioDecoder: Audio stream not found")

    def get_format(self):
        """Returns the WAVEFORMATEX data which has more information thah audio_format"""
        return self._wfx

    def _load_video(self, stream=MF_SOURCE_READER_FIRST_VIDEO_STREAM):
        self._video_stream_index = stream

        # Get what the native/real media type is (video only)
        imfmedia = IMFMediaType()

        try:
            self._source_reader.GetCurrentMediaType(
                self._video_stream_index, byref(imfmedia)
            )
        except OSError as err:
            if err.winerror == MF_E_INVALIDSTREAMNUMBER:
                assert _debug("WMFVideoDecoder: No video stream found.")
            return

        assert _debug("WMFVideoDecoder: Found Video Stream")

        # All video is basically compressed, try to decompress.
        uncompressed_mt = IMFMediaType()
        MFCreateMediaType(byref(uncompressed_mt))

        imfmedia.CopyAllItems(uncompressed_mt)

        imfmedia.Release()

        uncompressed_mt.SetGUID(MF_MT_SUBTYPE, MFVideoFormat_ARGB32)
        uncompressed_mt.SetUINT32(MF_MT_INTERLACE_MODE, MFVideoInterlace_Progressive)
        uncompressed_mt.SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, 1)

        try:
            self._source_reader.SetCurrentMediaType(
                self._video_stream_index, None, uncompressed_mt
            )
        except OSError as err:  # Can't decode codec.
            raise DecodeException(err) from None

        height, width = self._get_attribute_size(uncompressed_mt, MF_MT_FRAME_SIZE)

        self.video_format = VideoFormat(width=width, height=height)
        assert _debug(f"WMFVideoDecoder: Frame width: {width} height: {height}")

        # Frame rate
        den, num = self._get_attribute_size(uncompressed_mt, MF_MT_FRAME_RATE)
        self.video_format.frame_rate = num / den
        assert _debug(
            f"WMFVideoDecoder: Frame Rate: {num} / {den} = {self.video_format.frame_rate}"
        )

        # Sometimes it can return negative? Variable bit rate? Needs further tests and examples.
        if self.video_format.frame_rate < 0:
            self.video_format.frame_rate = 30000 / 1001
            assert _debug(
                "WARNING: Negative frame rate, attempting to use default, but may experience issues."
            )

        # Pixel ratio
        den, num = self._get_attribute_size(uncompressed_mt, MF_MT_PIXEL_ASPECT_RATIO)
        self.video_format.sample_aspect = num / den
        assert _debug(
            f"WMFVideoDecoder: Pixel Ratio: {num} / {den} = {self.video_format.sample_aspect}"
        )

    def get_audio_data(self, num_bytes, compensation_time=0.0):
        flags = DWORD()
        timestamp = c_longlong()

        imf_sample = IMFSample()
        imf_buffer = IMFMediaBuffer()

        while True:
            self._source_reader.ReadSample(
                self._audio_stream_index,
                0,
                None,
                byref(flags),
                byref(timestamp),
                byref(imf_sample),
            )

            if flags.value & MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED:
                assert _debug("WMFAudioDecoder: Data is no longer valid.")
                break

            if flags.value & MF_SOURCE_READERF_ENDOFSTREAM:
                assert _debug("WMFAudioDecoder: End of data from stream source.")
                break

            if not imf_sample:
                assert _debug("WMFAudioDecoder: No sample.")
                continue

            # Convert to single buffer as a sample could potentially(rarely) have multiple buffers.
            imf_sample.ConvertToContiguousBuffer(byref(imf_buffer))

            audio_data_ptr = POINTER(BYTE)()
            audio_data_length = DWORD()

            imf_buffer.Lock(byref(audio_data_ptr), None, byref(audio_data_length))

            audio_data = string_at(audio_data_ptr, audio_data_length.value)

            imf_buffer.Unlock()
            imf_buffer.Release()
            imf_sample.Release()

            return AudioData(
                audio_data,
                audio_data_length.value,
                timestamp_from_wmf(timestamp.value),
                audio_data_length.value / self.audio_format.sample_rate,
                [],
            )

        return None

    def get_next_video_frame(self, skip_empty_frame=True):
        video_data_length = DWORD()
        flags = DWORD()
        timestamp = c_longlong()

        if self._current_video_sample:
            self._current_video_buffer.Release()
            self._current_video_sample.Release()

        self._current_video_sample = IMFSample()
        self._current_video_buffer = IMFMediaBuffer()

        while True:
            self._source_reader.ReadSample(
                self._video_stream_index,
                0,
                None,
                byref(flags),
                byref(timestamp),
                byref(self._current_video_sample),
            )

            if flags.value & MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED:
                assert _debug("WMFVideoDecoder: Data is no longer valid.")

                # Get Major media type (Audio, Video, etc)
                new = IMFMediaType()
                self._source_reader.GetCurrentMediaType(
                    self._video_stream_index, byref(new)
                )

                # Sometimes this happens once. I think this only
                # changes if the stride is added/changed before playback?
                stride = c_uint32()
                new.GetUINT32(MF_MT_DEFAULT_STRIDE, byref(stride))
                new.Release()

                self._stride = stride.value

            if flags.value & MF_SOURCE_READERF_ENDOFSTREAM:
                self._timestamp = None
                assert _debug("WMFVideoDecoder: End of data from stream source.")
                break

            if not self._current_video_sample:
                assert _debug("WMFVideoDecoder: No sample.")
                continue

            self._current_video_buffer = IMFMediaBuffer()

            # Convert to single buffer as a sample could potentially have multiple buffers.
            self._current_video_sample.ConvertToContiguousBuffer(
                byref(self._current_video_buffer)
            )

            video_data = POINTER(BYTE)()

            self._current_video_buffer.Lock(
                byref(video_data), None, byref(video_data_length)
            )

            width = self.video_format.width
            height = self.video_format.height

            # buffer = create_string_buffer(size)
            self._timestamp = timestamp_from_wmf(timestamp.value)

            self._current_video_buffer.Unlock()

            # This is made with the assumption that the video frame will be blitted into the player texture immediately
            # after, and then cleared next frame attempt.
            return image.ImageData(width, height, "BGRA", video_data, self._stride)

        return None

    def get_next_video_timestamp(self):
        return self._timestamp

    def seek(self, timestamp):
        timestamp = min(timestamp, self._duration) if self._duration else timestamp

        prop = PROPVARIANT()
        prop.vt = VT_I8
        prop.llVal = timestamp_to_wmf(timestamp)

        pos_com = com.GUID(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        try:
            self._source_reader.SetCurrentPosition(pos_com, prop)
        except OSError as err:
            warnings.warn(str(err))

        ole32.PropVariantClear(byref(prop))

    @staticmethod
    def _get_attribute_size(attributes, guidKey):
        """Convert int64 attributes to int32"""  # HI32/LOW32
        size = c_uint64()
        attributes.GetUINT64(guidKey, size)
        lParam = size.value

        x = c_int32(lParam).value
        y = c_int32(lParam >> 32).value
        return x, y

    def set_config_attributes(self):
        """Here we set user specified attributes, by default we try to set low latency mode. (Win7+)"""
        if self.low_latency or self.decode_video:
            self._attributes = IMFAttributes()

            MFCreateAttributes(byref(self._attributes), 3)

        if self.low_latency and WINDOWS_7_OR_GREATER:
            self._attributes.SetUINT32(byref(MF_LOW_LATENCY), 1)

            assert _debug("WMFAudioDecoder: Setting configuration attributes.")

        # If it's a video we need to enable the streams to be accessed.
        if self.decode_video:
            self._attributes.SetUINT32(
                byref(MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS), 1
            )
            self._attributes.SetUINT32(
                byref(MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING), 1
            )

            assert _debug("WMFVideoDecoder: Setting configuration attributes.")

    def __del__(self):
        if self._source_reader:
            self._source_reader.Release()

        if self._stream_obj:
            self._stream_obj.Release()

        if self._imf_bytestream:
            self._imf_bytestream.Release()

        if self._current_video_sample:
            self._current_video_buffer.Release()
            self._current_video_sample.Release()


#########################################
#   Decoder class:
#########################################


class WMFDecoder(MediaDecoder):
    def __init__(self):
        self.MFShutdown = None

        try:
            MFStartup(MF_VERSION, 0)
        except OSError as err:
            raise ImportError("WMF could not startup:", err.strerror)

        self.extensions = self._build_decoder_extensions()

        self.MFShutdown = MFShutdown

        assert _debug("Windows Media Foundation: Initialized.")

    @staticmethod
    def _build_decoder_extensions():
        """Extension support varies depending on OS version."""
        extensions = []
        if WINDOWS_VISTA_OR_GREATER:
            extensions.extend(
                [
                    ".asf",
                    ".wma",
                    ".wmv",
                    ".mp3",
                    ".sami",
                    ".smi",
                ]
            )

        if WINDOWS_7_OR_GREATER:
            extensions.extend(
                [
                    ".3g2",
                    ".3gp",
                    ".3gp2",
                    ".3gp",
                    ".aac",
                    ".adts",
                    ".avi",
                    ".m4a",
                    ".m4v",
                    # '.wav'  # Can do wav, but we have a WAVE decoder.
                ]
            )

        if WINDOWS_10_ANNIVERSARY_UPDATE_OR_GREATER:
            extensions.extend([".flac"])

        return extensions

    def get_file_extensions(self):
        return self.extensions

    def decode(self, filename, file, streaming=True):
        if streaming:
            return WMFSource(filename, file)
        return StaticSource(WMFSource(filename, file))

    def __del__(self):
        if self.MFShutdown is not None:
            self.MFShutdown()


def get_decoders():
    return [WMFDecoder()]


def get_encoders():
    return []
